# Phase 2.2: RLS（再帰最小二乗法）実装仕様

**Issue**: #10  
**目的**: 実時間でプラントパラメータを推定し、STRの基盤となるRLSアルゴリズムを実装・検証する

---

## 数学的仕様

### 対応プラントモデル

#### 1次プラント（Phase 2.2 実装対象）
```
y(k) = a * y(k-1) + b * u(k-1)
```

- **パラメータベクトル**: `θ = [a, b]^T` (2×1)
- **回帰ベクトル**: `φ(k) = [y(k-1), u(k-1)]^T` (2×1)
- **予測モデル**: `ŷ(k) = φ(k)^T * θ(k-1)`
- **予測誤差**: `e(k) = y(k) - ŷ(k)`

#### 2次プラント（将来拡張）
```
y(k) = a1*y(k-1) + a2*y(k-2) + b1*u(k-1) + b2*u(k-2)
```

- **パラメータベクトル**: `θ = [a1, a2, b1, b2]^T` (4×1)
- **回帰ベクトル**: `φ(k) = [y(k-1), y(k-2), u(k-1), u(k-2)]^T` (4×1)

---

## RLSアルゴリズム

### 更新式（忘却係数付き）

**ステップ k での処理**:

1. **適応ゲイン計算**  
   ```
   K(k) = P(k-1) * φ(k) / (λ + φ(k)^T * P(k-1) * φ(k))
   ```
   - `K(k)`: 2×1 ゲインベクトル
   - `λ`: 忘却係数 (0.9 ≤ λ ≤ 1.0)

2. **パラメータ更新**  
   ```
   θ(k) = θ(k-1) + K(k) * e(k)
   ```

3. **共分散行列更新**  
   ```
   P(k) = (1/λ) * (P(k-1) - K(k) * φ(k)^T * P(k-1))
   ```
   - `P(k)`: 2×2 共分散行列（パラメータの不確実性を表現）

---

## 初期化パラメータ

### 初期共分散行列 P(0)
```
P(0) = α * I  (I: 2×2 単位行列)
```

| α の値 | 意味 | 効果 |
|--------|------|------|
| **1000～10000** | 初期推定値をほとんど信じていない | 最初の数ステップで急速に学習、収束が速い |
| **100～1000** | 中程度の不確実性 | バランスの取れた学習 |
| **10～100** | 初期推定値にある程度の信頼 | 慎重な学習、収束が遅い |

**推奨値**: `α = 1000` （教科書的な標準値）

**意味**:
- P(k)が大きい → パラメータ推定の不確実性が高い → 新しいデータを信じやすい（学習速度↑）
- P(k)が小さい → パラメータ推定の信頼度が高い → 新しいデータを慎重に取り入れる（学習速度↓）

### 初期パラメータ推定値 θ(0)
```
θ(0) = [0.5, 0.3]^T
```

- Plant クラスのデフォルト (`a=0.8, b=0.5`) に近い適当な初期値
- P(0)が大きいので、初期値の精度は収束速度に大きく影響しない

### 忘却係数 λ
```
λ = 0.95～1.0  (UI で調整可能)
```

- **λ = 1.0**: 標準RLS（全データを等しく扱う）
- **λ < 1.0**: 過去のデータを忘却（時変プラント対応）
  - 0.98～0.99: 緩やかな忘却
  - 0.95～0.97: 中程度の忘却
  - 0.90～0.94: 強い忘却

**推奨初期値**: `λ = 0.98` （時変対応しつつ安定）

---

## 実装方針

### クラス設計: `lib/control/rls.dart`

```dart
class RLS {
  // パラメータ
  final int parameterCount;  // θのサイズ（1次: 2, 2次: 4）
  double lambda;             // 忘却係数
  
  // 状態変数
  List<double> theta;        // 推定パラメータ θ(k)
  List<List<double>> P;      // 共分散行列 P(k)
  
  // 初期化
  RLS({
    required this.parameterCount,
    this.lambda = 0.98,
    double initialCovarianceScale = 1000.0,
  });
  
  // 1ステップ更新
  void update(List<double> phi, double y);
  
  // リセット
  void reset();
  
  // ゲッター
  double get estimatedA => theta[0];
  double get estimatedB => theta[1];
}
```

### テスト方針: `test/control/rls_test.dart`

**テストケース** (90%+ coverage 必須):

1. **初期化テスト**
   - θ(0), P(0) が正しく設定される
   - パラメータカウントが正しい

2. **推定精度テスト**
   - 既知パラメータのプラントで y, u を生成
   - RLS に渡して推定値が真値に収束するか確認
   - 許容誤差: `|θ̂ - θ_true| < 0.05` 以内

3. **忘却係数テスト**
   - λ = 1.0 と λ = 0.95 で収束速度が異なることを確認

4. **リセットテスト**
   - reset() 後に初期状態に戻ることを確認

5. **数値安定性テスト**
   - P(k) が正定値を保つことを確認（対角成分 > 0）
   - ゼロ除算が発生しないことを確認

---

## UI実装方針

### Simulator 統合
- `lib/simulation/simulator.dart` に RLS インスタンス追加
- RLS有効/無効フラグ
- 各ステップで `rls.update(phi, y)` 呼び出し

### UI要素 (`lib/ui/main_screen.dart`)

1. **RLS ON/OFFトグル**
   - Switch widget でRLS有効化

2. **忘却係数スライダー**
   - 範囲: 0.90 ～ 1.00
   - ステップ: 0.01

3. **推定値表示セクション**
   - 真値 vs 推定値の表形式表示
   - 例:
     ```
     パラメータ | 真値  | 推定値
     ----------|-------|-------
     a         | 0.800 | 0.795
     b         | 0.500 | 0.503
     ```

4. **推定値時系列グラフ**
   - `historyEstimatedA`, `historyEstimatedB` を追加
   - 真値（一定線）と推定値（変動）を重ねて表示
   - fl_chart の LineChart で実装

---

## 受け入れ基準（Issue #10）

- [x] RLSが安定に動作し、数ステップで推定値が真値に接近
- [x] 忘却係数をUI(0.9～1.0)で調整可能
- [x] グラフで推定パラメータの時系列が確認できる
- [x] テスト（初期化、推定精度、リセット）全部Green
- [x] 分析・フォーマット・カバレッジOK（90%+）

---

## 参考文献

1. **Ljung, L.** (1999). *System Identification: Theory for the User* (2nd ed.). Prentice Hall.
2. **Åström, K. J., & Wittenmark, B.** (1995). *Adaptive Control* (2nd ed.). Addison-Wesley.
3. **Haykin, S.** (2002). *Adaptive Filter Theory* (4th ed.). Prentice Hall.

---

## 実装スケジュール（Phase 2.2）

| ステップ | 内容 | 所要時間目安 |
|---------|------|------------|
| 1 | `lib/control/rls.dart` 実装 | 1-2h |
| 2 | `test/control/rls_test.dart` 実装 | 1-2h |
| 3 | Simulator 統合 | 1h |
| 4 | UI 実装（RLS ON/OFF, スライダー） | 1-2h |
| 5 | 推定値グラフ実装 | 1-2h |
| 6 | 統合テスト・デバッグ | 1-2h |

**合計**: 6-11時間

---

## 次のフェーズ（Phase 2.3）

Issue #11: STR（自己調整制御）の実装
- RLSで推定したパラメータを使ってPIDゲインを動的調整
- 極配置による制御則設計
- PID vs STR の性能比較
